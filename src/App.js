import React, { useState, useEffect, useCallback } from 'react';
import apiService from './services/api';
import Login from './components/Login';

const categories = [
  { value: '', label: '„Åô„Åπ„Å¶„ÅÆ„Ç´„ÉÜ„Ç¥„É™' },
  { value: '‰ªï‰∫ã', label: '‰ªï‰∫ã' },
  { value: '„Éó„É©„Ç§„Éô„Éº„Éà', label: '„Éó„É©„Ç§„Éô„Éº„Éà' },
  { value: '„Ç¢„Ç§„Éá„Ç¢', label: '„Ç¢„Ç§„Éá„Ç¢' },
  { value: 'Ë≤∑„ÅÑÁâ©', label: 'Ë≤∑„ÅÑÁâ©' },
  { value: '„Åù„ÅÆ‰ªñ', label: '„Åù„ÅÆ‰ªñ' }
];

const sortOptions = [
  { value: 'updated', label: 'Êõ¥Êñ∞Êó•È†Ü' },
  { value: 'created', label: '‰ΩúÊàêÊó•È†Ü' },
  { value: 'alphabetical', label: 'ÊñáÂ≠óÈ†Ü' },
  { value: 'favorites', label: '„ÅäÊ∞ó„Å´ÂÖ•„ÇäÈ†Ü' }
];

// „Éá„Ç∏„Çø„É´ÊôÇË®à„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
const DigitalClock = () => {
  const [time, setTime] = useState(new Date());

  useEffect(() => {
    const timer = setInterval(() => {
      setTime(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  const formatTime = (date) => {
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    const seconds = date.getSeconds().toString().padStart(2, '0');
    const dateStr = date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      weekday: 'short'
    });
    return `${dateStr} ${hours}:${minutes}:${seconds}`;
  };

  return (
    <div className="digital-clock">
      {formatTime(time)}
    </div>
  );
};

// „Ç´„É≥„Éê„É≥„Ç´„Éº„Éâ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
const KanbanCard = ({ todo, onDelete, onDragStart }) => {
  const formatDate = (dateString) => {
    if (!dateString) return null;
    const date = new Date(dateString);
    return date.toLocaleDateString('ja-JP');
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'high': return '#f87171';
      case 'medium': return '#fbbf24';
      case 'low': return '#10b981';
      default: return '#6b7280';
    }
  };

  const getPriorityLabel = (priority) => {
    switch (priority) {
      case 'high': return 'È´ò';
      case 'medium': return '‰∏≠';
      case 'low': return '‰Ωé';
      default: return '‰∏≠';
    }
  };

  return (
    <div 
      className="kanban-card"
      draggable={true}
      onDragStart={(e) => onDragStart(e, todo)}
    >
      <div className="kanban-card-header">
        <span 
          className="kanban-priority" 
          style={{ backgroundColor: getPriorityColor(todo.priority) }}
        >
          {getPriorityLabel(todo.priority)}
        </span>
        <button 
          className="btn btn-danger btn-tiny"
          onClick={() => onDelete(todo.id)}
        >
          √ó
        </button>
      </div>
      <h4 className="kanban-card-title">{todo.title}</h4>
      {todo.description && (
        <p className="kanban-card-description">{todo.description}</p>
      )}
      {todo.dueDate && (
        <div className="kanban-card-due-date">
          üìÖ {formatDate(todo.dueDate)}
        </div>
      )}
    </div>
  );
};

// „Ç´„É≥„Éê„É≥„Ç´„É©„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
const KanbanColumn = ({ title, status, todos, onDrop, onDragOver, onDelete, onDragStart }) => {
  return (
    <div 
      className="kanban-column"
      onDragOver={onDragOver}
      onDrop={(e) => onDrop(e, status)}
    >
      <div className="kanban-column-header">
        <h3>{title}</h3>
        <span className="kanban-count">{todos.length}</span>
      </div>
      <div className="kanban-cards">
        {todos.map(todo => (
          <KanbanCard
            key={todo.id}
            todo={todo}
            onDelete={onDelete}
            onDragStart={onDragStart}
          />
        ))}
      </div>
    </div>
  );
};

// Todo„Ç¢„Ç§„ÉÜ„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
const TodoItem = ({ todo, onDelete, onToggleCompleted }) => {
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffTime = Math.abs(now - date);
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
      return date.toLocaleTimeString('ja-JP', { 
        hour: '2-digit', 
        minute: '2-digit' 
      });
    } else if (diffDays === 1) {
      return 'Êò®Êó•';
    } else if (diffDays < 7) {
      return `${diffDays}Êó•Ââç`;
    } else {
      return date.toLocaleDateString('ja-JP');
    }
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'high': return '#f87171';
      case 'medium': return '#fbbf24';
      case 'low': return '#10b981';
      default: return '#6b7280';
    }
  };

  const getPriorityLabel = (priority) => {
    switch (priority) {
      case 'high': return 'È´ò';
      case 'medium': return '‰∏≠';
      case 'low': return '‰Ωé';
      default: return '‰∏≠';
    }
  };

  return (
    <div className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <div className="todo-header">
        <div className="todo-meta">
          <span className="todo-date">{formatDate(todo.createdAt)}</span>
          <span 
            className="todo-priority" 
            style={{ backgroundColor: getPriorityColor(todo.priority) }}
          >
            {getPriorityLabel(todo.priority)}
          </span>
          {todo.dueDate && (
            <span className="todo-due-date">
              ÊúüÈôê: {new Date(todo.dueDate).toLocaleDateString('ja-JP')}
            </span>
          )}
        </div>
        <div className="todo-actions">
          <button 
            className={`btn btn-todo-toggle btn-small ${todo.completed ? 'completed' : ''}`}
            onClick={() => onToggleCompleted(todo.id)}
          >
            {todo.completed ? '‚úì' : '‚óã'}
          </button>
          <button 
            className="btn btn-danger btn-small"
            onClick={() => onDelete(todo.id)}
          >
            ÂâäÈô§
          </button>
        </div>
      </div>
      <div className="todo-content">
        <h3 className={`todo-title ${todo.completed ? 'completed' : ''}`}>
          {todo.title}
        </h3>
        {todo.description && (
          <p className="todo-description">{todo.description}</p>
        )}
      </div>
    </div>
  );
};

// „É°„É¢„Ç¢„Ç§„ÉÜ„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
const MemoItem = ({ memo, onDelete, onToggleFavorite, onUpdateCategory, showSimilarity = false }) => {
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffTime = Math.abs(now - date);
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
      return date.toLocaleTimeString('ja-JP', { 
        hour: '2-digit', 
        minute: '2-digit' 
      });
    } else if (diffDays === 1) {
      return 'Êò®Êó•';
    } else if (diffDays < 7) {
      return `${diffDays}Êó•Ââç`;
    } else {
      return date.toLocaleDateString('ja-JP');
    }
  };

  const handleCategoryChange = (e) => {
    onUpdateCategory(memo.id, e.target.value);
  };

  return (
    <div className={`memo-item ${memo.isFavorite ? 'favorite' : ''}`}>
      <div className="memo-header">
        <div className="memo-meta">
          <span className="memo-date">{formatDate(memo.updatedAt)}</span>
          {showSimilarity && memo.similarity && (
            <span className="similarity-score">
              È°û‰ººÂ∫¶: {(memo.similarity * 100).toFixed(1)}%
            </span>
          )}
          <select 
            className="category-select" 
            value={memo.category}
            onChange={handleCategoryChange}
          >
            <option value="‰ªï‰∫ã">‰ªï‰∫ã</option>
            <option value="„Éó„É©„Ç§„Éô„Éº„Éà">„Éó„É©„Ç§„Éô„Éº„Éà</option>
            <option value="„Ç¢„Ç§„Éá„Ç¢">„Ç¢„Ç§„Éá„Ç¢</option>
            <option value="Ë≤∑„ÅÑÁâ©">Ë≤∑„ÅÑÁâ©</option>
            <option value="„Åù„ÅÆ‰ªñ">„Åù„ÅÆ‰ªñ</option>
          </select>
        </div>
        <div className="memo-actions">
          <button 
            className={`btn btn-favorite btn-small ${memo.isFavorite ? 'active' : ''}`}
            onClick={() => onToggleFavorite(memo.id)}
          >
            {memo.isFavorite ? '‚òÖ' : '‚òÜ'}
          </button>
          <button 
            className="btn btn-danger btn-small"
            onClick={() => onDelete(memo.id)}
          >
            ÂâäÈô§
          </button>
        </div>
      </div>
      {memo.tags.length > 0 && (
        <div className="memo-tags">
          {memo.tags.map(tag => (
            <span key={tag} className="tag">#{tag}</span>
          ))}
        </div>
      )}
      <div className="memo-content-display">
        {memo.content}
      </div>
    </div>
  );
};

// „É°„Ç§„É≥„Ç¢„Éó„É™„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
const App = () => {
  const [memos, setMemos] = useState([]);
  const [todos, setTodos] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [newMemoContent, setNewMemoContent] = useState('');
  const [currentCategory, setCurrentCategory] = useState('');
  const [currentSort, setCurrentSort] = useState('created');
  const [showFavoritesOnly, setShowFavoritesOnly] = useState(false);
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [authLoading, setAuthLoading] = useState(false);
  const [isVectorSearch, setIsVectorSearch] = useState(false);
  const [vectorSearchResults, setVectorSearchResults] = useState([]);
  const [isVectorSearching, setIsVectorSearching] = useState(false);
  const [suggestedTags, setSuggestedTags] = useState([]);
  const [suggestedCategory, setSuggestedCategory] = useState('');
  const [activeTab, setActiveTab] = useState('memos');
  const [newTodoTitle, setNewTodoTitle] = useState('');
  const [newTodoDescription, setNewTodoDescription] = useState('');
  const [newTodoPriority, setNewTodoPriority] = useState('medium');
  const [newTodoDueDate, setNewTodoDueDate] = useState('');
  const [draggedTodo, setDraggedTodo] = useState(null);

  // ÂàùÊúüÂåñÊôÇ„Å´„É¶„Éº„Ç∂„ÉºÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
  useEffect(() => {
    checkAuthStatus();
  }, []);

  // „É¶„Éº„Ç∂„Éº„Åå„É≠„Ç∞„Ç§„É≥„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„Åø„É°„É¢„Å®Todo„ÇíË™≠„ÅøËæº„Åø
  useEffect(() => {
    if (user) {
      loadMemos();
      loadTodos();
    }
  }, [user]);

  const checkAuthStatus = async () => {
    try {
      const token = localStorage.getItem('token');
      if (token) {
        const response = await apiService.getCurrentUser();
        setUser(response.user);
      }
    } catch (error) {
      console.error('Ë™çË®ºÁ¢∫Ë™ç„Ç®„É©„Éº:', error);
      localStorage.removeItem('token');
    } finally {
      setIsLoading(false);
    }
  };

  const loadMemos = async () => {
    try {
      const memosData = await apiService.getMemos();
      setMemos(memosData);
    } catch (error) {
      console.error('„É°„É¢„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      if (error.message.includes('401') || error.message.includes('403')) {
        // Ë™çË®º„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÄÅ„É≠„Ç∞„Ç¢„Ç¶„ÉàÂá¶ÁêÜ
        handleLogout();
      }
    }
  };

  const loadTodos = async () => {
    try {
      const todosData = await apiService.getTodos();
      setTodos(todosData);
    } catch (error) {
      console.error('Todo„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      if (error.message.includes('401') || error.message.includes('403')) {
        // Ë™çË®º„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÄÅ„É≠„Ç∞„Ç¢„Ç¶„ÉàÂá¶ÁêÜ
        handleLogout();
      }
    }
  };

  const handleLogin = async (username, password, email, displayName) => {
    setAuthLoading(true);
    try {
      let response;
      if (email) {
        // ÁôªÈå≤„É¢„Éº„Éâ
        response = await apiService.register(username, email, password, displayName);
      } else {
        // „É≠„Ç∞„Ç§„É≥„É¢„Éº„Éâ
        response = await apiService.login(username, password);
      }
      
      setUser(response.user);
      setMemos([]); // „É°„É¢„Çí„ÇØ„É™„Ç¢
      setTodos([]); // Todo„Çí„ÇØ„É™„Ç¢
    } catch (error) {
      console.error('Ë™çË®º„Ç®„É©„Éº:', error);
      throw error;
    } finally {
      setAuthLoading(false);
    }
  };

  const handleLogout = async () => {
    try {
      await apiService.logout();
      setUser(null);
      setMemos([]);
      setTodos([]);
    } catch (error) {
      console.error('„É≠„Ç∞„Ç¢„Ç¶„Éà„Ç®„É©„Éº:', error);
    }
  };

  // „É°„É¢„Çí„Çµ„Éº„Éê„Éº„Å´‰øùÂ≠òÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ‰ªò„ÅçÔºâ
  const saveMemos = useCallback((memosToSave) => {
    localStorage.setItem('memos', JSON.stringify(memosToSave));
  }, []);

  // IDÁîüÊàê
  const generateId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  };

  // „Çø„Ç∞ÊäΩÂá∫
  const extractTags = (content) => {
    const tagRegex = /#([\w\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]+)/g;
    const tags = [];
    let match;
    while ((match = tagRegex.exec(content)) !== null) {
      tags.push(match[1]);
    }
    return [...new Set(tags)];
  };

  // Êñ∞„Åó„ÅÑ„É°„É¢„ÇíËøΩÂä†
  const addMemo = async () => {
    const newMemo = {
      id: generateId(),
      content: '',
      category: '„Åù„ÅÆ‰ªñ',
      tags: [],
      isFavorite: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    try {
      await apiService.createMemo(newMemo);
      const updatedMemos = [newMemo, ...memos];
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
    } catch (error) {
      console.error('„É°„É¢„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´„ÅÆ„ÅøÊõ¥Êñ∞
      const updatedMemos = [newMemo, ...memos];
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
    }
  };

  // Ëá™Âãï„Çø„Ç∞‰ªò„Åë„Éó„É¨„Éì„É•„Éº„ÇíÂÆüË°å
  const previewAutoTags = useCallback(async (content) => {
    if (!content || content.trim().length < 3) {
      setSuggestedTags([]);
      setSuggestedCategory('');
      return;
    }

    try {
      const result = await apiService.previewAutoTags(content);
      setSuggestedTags(result.suggestedTags || []);
      setSuggestedCategory(result.suggestedCategory || '');
    } catch (error) {
      console.error('Ëá™Âãï„Çø„Ç∞„Éó„É¨„Éì„É•„Éº„Ç®„É©„Éº:', error);
      setSuggestedTags([]);
      setSuggestedCategory('');
    }
  }, []);

  // „Éá„Éê„Ç¶„É≥„Çπ‰ªò„Åç„ÅÆËá™Âãï„Çø„Ç∞„Éó„É¨„Éì„É•„Éº
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      previewAutoTags(newMemoContent);
    }, 1000); // 1ÁßíÂæå„Å´ÂÆüË°å

    return () => clearTimeout(timeoutId);
  }, [newMemoContent, previewAutoTags]);

  // ‰∏ÄË®Ä„É°„É¢„ÇíÊäïÁ®ø
  const postQuickMemo = async () => {
    if (!newMemoContent.trim()) return;

    const newMemo = {
      id: generateId(),
      content: newMemoContent.trim(),
      category: suggestedCategory || '„Åù„ÅÆ‰ªñ', // Êé®Â•®„Ç´„ÉÜ„Ç¥„É™„Çí‰ΩøÁî®
      tags: extractTags(newMemoContent), // ÊâãÂãï„Çø„Ç∞„ÅØ‰øùÊåÅ„ÄÅËá™Âãï„Çø„Ç∞„ÅØ„Çµ„Éº„Éê„Éº„ÅßËøΩÂä†
      isFavorite: false,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    try {
      const response = await apiService.createMemo(newMemo);
      
      // „Çµ„Éº„Éê„Éº„Åã„ÇâËøî„Åï„Çå„ÅüËá™ÂãïÁîüÊàê„Çø„Ç∞„ÇíÂê´„ÇÄ„É°„É¢„Éá„Éº„Çø„Çí‰ΩøÁî®
      const updatedMemos = [response, ...memos];
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
      setNewMemoContent(''); // ÂÖ•ÂäõÊ¨Ñ„Çí„ÇØ„É™„Ç¢
      setSuggestedTags([]); // ÊèêÊ°à„Çø„Ç∞„Çí„ÇØ„É™„Ç¢
      setSuggestedCategory(''); // ÊèêÊ°à„Ç´„ÉÜ„Ç¥„É™„Çí„ÇØ„É™„Ç¢
    } catch (error) {
      console.error('„É°„É¢„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´„ÅÆ„ÅøÊõ¥Êñ∞
      const updatedMemos = [newMemo, ...memos];
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
      setNewMemoContent(''); // ÂÖ•ÂäõÊ¨Ñ„Çí„ÇØ„É™„Ç¢
      setSuggestedTags([]); // ÊèêÊ°à„Çø„Ç∞„Çí„ÇØ„É™„Ç¢
      setSuggestedCategory(''); // ÊèêÊ°à„Ç´„ÉÜ„Ç¥„É™„Çí„ÇØ„É™„Ç¢
    }
  };


  // „É°„É¢„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÇíÊõ¥Êñ∞
  const updateMemoCategory = async (id, category) => {
    const memo = memos.find(m => m.id === id);
    if (!memo) return;

    const updatedMemo = {
      ...memo,
      category,
      updatedAt: new Date().toISOString()
    };

    try {
      await apiService.updateMemo(id, updatedMemo);
      const updatedMemos = memos.map(m => m.id === id ? updatedMemo : m);
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
    } catch (error) {
      console.error('„Ç´„ÉÜ„Ç¥„É™„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      const updatedMemos = memos.map(m => m.id === id ? updatedMemo : m);
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
    }
  };

  // „ÅäÊ∞ó„Å´ÂÖ•„ÇäÂàá„ÇäÊõø„Åà
  const toggleFavorite = async (id) => {
    const memo = memos.find(m => m.id === id);
    if (!memo) return;

    const updatedMemo = {
      ...memo,
      isFavorite: !memo.isFavorite,
      updatedAt: new Date().toISOString()
    };

    try {
      await apiService.updateMemo(id, updatedMemo);
      const updatedMemos = memos.map(m => m.id === id ? updatedMemo : m);
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
    } catch (error) {
      console.error('„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      const updatedMemos = memos.map(m => m.id === id ? updatedMemo : m);
      setMemos(updatedMemos);
      saveMemos(updatedMemos);
    }
  };

  // „É°„É¢„ÇíÂâäÈô§
  const deleteMemo = async (id) => {
    if (window.confirm('Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
      try {
        await apiService.deleteMemo(id);
        const updatedMemos = memos.filter(memo => memo.id !== id);
        setMemos(updatedMemos);
        saveMemos(updatedMemos);
      } catch (error) {
        console.error('„É°„É¢„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
        const updatedMemos = memos.filter(memo => memo.id !== id);
        setMemos(updatedMemos);
        saveMemos(updatedMemos);
      }
    }
  };

  // ÂÖ®„É°„É¢„ÇíÂâäÈô§
  const clearAllMemos = async () => {
    if (window.confirm('ÂÖ®„Å¶„ÅÆ„É°„É¢„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
      try {
        await apiService.deleteAllMemos();
        setMemos([]);
        saveMemos([]);
      } catch (error) {
        console.error('ÂÖ®„É°„É¢„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
        setMemos([]);
        saveMemos([]);
      }
    }
  };

  // „Ç®„ÇØ„Çπ„Éù„Éº„Éà
  const exportMemos = async () => {
    try {
      const exportData = await apiService.exportMemos();
      
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(dataBlob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `„É°„É¢„Éá„Éº„Çø_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà
      const exportData = {
        memos,
        exportDate: new Date().toISOString(),
        totalCount: memos.length
      };
      
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(dataBlob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `„É°„É¢„Éá„Éº„Çø_${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  };

  // Ê§úÁ¥¢„Çí„ÇØ„É™„Ç¢
  const clearSearch = () => {
    setSearchQuery('');
    setIsVectorSearch(false);
    setVectorSearchResults([]);
  };

  // „Éô„ÇØ„Éà„É´Ê§úÁ¥¢„ÇíÂÆüË°å
  const performVectorSearch = async () => {
    if (!searchQuery.trim()) return;

    setIsVectorSearching(true);
    try {
      const result = await apiService.vectorSearch(searchQuery);
      setVectorSearchResults(result.memos || []);
      setIsVectorSearch(true);
    } catch (error) {
      console.error('„Éô„ÇØ„Éà„É´Ê§úÁ¥¢„Ç®„É©„Éº:', error);
      setVectorSearchResults([]);
    } finally {
      setIsVectorSearching(false);
    }
  };

  // „Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÂÜçÊßãÁØâ
  const reindexMemos = async () => {
    try {
      setIsLoading(true);
      await apiService.reindexMemos();
      alert('„É°„É¢„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂÜçÊßãÁØâ„Åó„Åæ„Åó„ÅüÔºÅ');
    } catch (error) {
      console.error('„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÂÜçÊßãÁØâ„Ç®„É©„Éº:', error);
      alert('„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÂÜçÊßãÁØâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
    } finally {
      setIsLoading(false);
    }
  };

  // TodoÈñ¢ÈÄ£„ÅÆÈñ¢Êï∞

  // IDÁîüÊàêÈñ¢Êï∞„ÇíÂÜçÂà©Áî®
  const generateTodoId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  };

  // Êñ∞„Åó„ÅÑTodo„ÇíËøΩÂä†
  const addTodo = async () => {
    if (!newTodoTitle.trim()) return;

    const newTodo = {
      id: generateTodoId(),
      title: newTodoTitle.trim(),
      description: newTodoDescription.trim(),
      completed: false,
      status: 'todo', // „Éá„Éï„Ç©„É´„Éà„ÅØ„ÄåÊú™ÁùÄÊâã„Äç
      priority: newTodoPriority,
      dueDate: newTodoDueDate || null,
      category: '„Åù„ÅÆ‰ªñ',
      tags: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    try {
      const response = await apiService.createTodo(newTodo);
      const updatedTodos = [response, ...todos];
      setTodos(updatedTodos);
      setNewTodoTitle('');
      setNewTodoDescription('');
      setNewTodoPriority('medium');
      setNewTodoDueDate('');
    } catch (error) {
      console.error('Todo„ÅÆ‰ΩúÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´„ÅÆ„ÅøÊõ¥Êñ∞
      const updatedTodos = [newTodo, ...todos];
      setTodos(updatedTodos);
      setNewTodoTitle('');
      setNewTodoDescription('');
      setNewTodoPriority('medium');
      setNewTodoDueDate('');
    }
  };

  // Todo„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂ§âÊõ¥
  const updateTodoStatus = async (id, newStatus) => {
    const todo = todos.find(t => t.id === id);
    if (!todo) return;

    const updatedTodo = {
      ...todo,
      status: newStatus,
      completed: newStatus === 'done',
      updatedAt: new Date().toISOString()
    };

    try {
      await apiService.updateTodo(id, updatedTodo);
      const updatedTodos = todos.map(t => t.id === id ? updatedTodo : t);
      setTodos(updatedTodos);
    } catch (error) {
      console.error('TodoÁä∂ÊÖã„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
      const updatedTodos = todos.map(t => t.id === id ? updatedTodo : t);
      setTodos(updatedTodos);
    }
  };

  // „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„ÉóÈñ¢Êï∞
  const handleDragStart = (e, todo) => {
    setDraggedTodo(todo);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
  };

  const handleDrop = (e, newStatus) => {
    e.preventDefault();
    if (draggedTodo && draggedTodo.status !== newStatus) {
      updateTodoStatus(draggedTodo.id, newStatus);
    }
    setDraggedTodo(null);
  };

  // Todo„ÇíÂâäÈô§
  const deleteTodo = async (id) => {
    if (window.confirm('Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
      try {
        await apiService.deleteTodo(id);
        const updatedTodos = todos.filter(todo => todo.id !== id);
        setTodos(updatedTodos);
      } catch (error) {
        console.error('Todo„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
        const updatedTodos = todos.filter(todo => todo.id !== id);
        setTodos(updatedTodos);
      }
    }
  };

  // ÂÖ®Todo„ÇíÂâäÈô§
  const clearAllTodos = async () => {
    if (window.confirm('ÂÖ®„Å¶„ÅÆTodo„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
      try {
        await apiService.deleteAllTodos();
        setTodos([]);
      } catch (error) {
        console.error('ÂÖ®Todo„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
        setTodos([]);
      }
    }
  };

  // Enter„Ç≠„Éº„ÅßÊäïÁ®ø
  const handleKeyPress = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (activeTab === 'memos') {
        postQuickMemo();
      } else {
        addTodo();
      }
    }
  };

  // „ÅäÊ∞ó„Å´ÂÖ•„Çä„Éï„Ç£„É´„Çø„Éº„ÇíÂàá„ÇäÊõø„Åà
  const toggleFavoritesOnly = () => {
    setShowFavoritesOnly(!showFavoritesOnly);
  };

  // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Å®„ÇΩ„Éº„Éà
  const getFilteredAndSortedMemos = () => {
    let filtered = memos;

    // „Ç´„ÉÜ„Ç¥„É™„Éï„Ç£„É´„Çø„Éº
    if (currentCategory) {
      filtered = filtered.filter(memo => memo.category === currentCategory);
    }

    // „ÅäÊ∞ó„Å´ÂÖ•„Çä„Éï„Ç£„É´„Çø„Éº
    if (showFavoritesOnly) {
      filtered = filtered.filter(memo => memo.isFavorite);
    }

    // Ê§úÁ¥¢„Éï„Ç£„É´„Çø„Éº
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(memo => 
        memo.content.toLowerCase().includes(query) ||
        memo.tags.some(tag => tag.toLowerCase().includes(query))
      );
    }

    // „ÇΩ„Éº„Éà
    filtered.sort((a, b) => {
      switch (currentSort) {
        case 'created':
          return new Date(b.createdAt) - new Date(a.createdAt);
        case 'alphabetical':
          return a.content.localeCompare(b.content);
        case 'favorites':
          if (a.isFavorite && !b.isFavorite) return -1;
          if (!a.isFavorite && b.isFavorite) return 1;
          return new Date(b.updatedAt) - new Date(a.updatedAt);
        default: // 'updated'
          return new Date(b.updatedAt) - new Date(a.updatedAt);
      }
    });

    return filtered;
  };

  const filteredMemos = isVectorSearch ? vectorSearchResults : getFilteredAndSortedMemos();

  const getEmptyMessage = () => {
    if (memos.length === 0) {
      return '„É°„É¢„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ„ÄåÊñ∞„Åó„ÅÑ„É°„É¢„Äç„Éú„Çø„É≥„Åß‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
    } else if (showFavoritesOnly) {
      return '„ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆ„É°„É¢„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ‚òÖ„Éú„Çø„É≥„Åß„ÅäÊ∞ó„Å´ÂÖ•„Çä„Å´ÁôªÈå≤„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
    } else {
      return 'Ê§úÁ¥¢ÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÂà•„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÅßË©¶„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
    }
  };

  // „É≠„Éº„Éá„Ç£„É≥„Ç∞‰∏≠„ÅÆË°®Á§∫
  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="loading">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
      </div>
    );
  }

  // „É≠„Ç∞„Ç§„É≥„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆË°®Á§∫
  if (!user) {
    return <Login onLogin={handleLogin} isLoading={authLoading} />;
  }

  return (
    <div className="container">
      <header>
        <DigitalClock />
        <div className="header-content">
          <h1>„Çπ„Éû„Éº„Éà„É°„É¢Â∏≥</h1>
          <div className="user-info">
            <span>„Åì„Çì„Å´„Å°„ÅØ„ÄÅ{user.displayName}„Åï„ÇìÔºÅ</span>
            <button className="btn btn-secondary btn-small" onClick={handleLogout}>
              „É≠„Ç∞„Ç¢„Ç¶„Éà
            </button>
          </div>
        </div>
        
        {/* „Çø„ÉñÂàá„ÇäÊõø„Åà */}
        <div className="tab-container">
          <button 
            className={`tab-btn ${activeTab === 'memos' ? 'active' : ''}`}
            onClick={() => setActiveTab('memos')}
          >
            üìù „É°„É¢
          </button>
          <button 
            className={`tab-btn ${activeTab === 'todos' ? 'active' : ''}`}
            onClick={() => setActiveTab('todos')}
          >
            ‚úÖ Todo
          </button>
        </div>
      </header>
      
      <div className="smart-controls">
        <div className="search-container">
          <input 
            type="text" 
            className="search-input" 
            placeholder="„É°„É¢„ÇíÊ§úÁ¥¢..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
          />
          <button 
            className="btn btn-info" 
            onClick={performVectorSearch}
            disabled={!searchQuery.trim() || isVectorSearching}
          >
            {isVectorSearching ? 'Ê§úÁ¥¢‰∏≠...' : 'AIÊ§úÁ¥¢'}
          </button>
          <button className="btn btn-secondary" onClick={clearSearch}>
            „ÇØ„É™„Ç¢
          </button>
        </div>
        
        <div className="filter-container">
          <select 
            className="filter-select"
            value={currentCategory}
            onChange={(e) => setCurrentCategory(e.target.value)}
          >
            {categories.map(cat => (
              <option key={cat.value} value={cat.value}>{cat.label}</option>
            ))}
          </select>
          
          <select 
            className="filter-select"
            value={currentSort}
            onChange={(e) => setCurrentSort(e.target.value)}
          >
            {sortOptions.map(opt => (
              <option key={opt.value} value={opt.value}>{opt.label}</option>
            ))}
          </select>
          
          <button 
            className={`btn btn-filter ${showFavoritesOnly ? 'active' : ''}`}
            onClick={toggleFavoritesOnly}
          >
            ‚òÖ „ÅäÊ∞ó„Å´ÂÖ•„Çä„ÅÆ„Åø
          </button>
        </div>
      </div>

      {/* „ÇØ„Ç§„ÉÉ„ÇØÂÖ•Âäõ„Çª„ÇØ„Ç∑„Éß„É≥ */}
      {activeTab === 'memos' ? (
        <div className="quick-memo-section">
          <div className="quick-memo-container">
            <input 
              type="text" 
              className="quick-memo-input" 
              placeholder="‰ªä‰Ωï„Åó„Å¶„ÇãÔºü‰∏ÄË®Ä„É°„É¢„ÇíÊäïÁ®ø..."
              value={newMemoContent}
              onChange={(e) => setNewMemoContent(e.target.value)}
              onKeyPress={handleKeyPress}
            />
            <button 
              className="btn btn-primary" 
              onClick={postQuickMemo}
              disabled={!newMemoContent.trim()}
            >
              ÊäïÁ®ø
            </button>
          </div>
          
          {/* Ëá™Âãï„Çø„Ç∞„Éó„É¨„Éì„É•„Éº */}
          {(suggestedTags.length > 0 || suggestedCategory) && (
            <div className="auto-tag-preview">
              {suggestedCategory && (
                <div className="suggested-category">
                  <span className="preview-label">Êé®Â•®„Ç´„ÉÜ„Ç¥„É™:</span>
                  <span className="preview-category">{suggestedCategory}</span>
                </div>
              )}
              {suggestedTags.length > 0 && (
                <div className="suggested-tags">
                  <span className="preview-label">Ëá™Âãï„Çø„Ç∞:</span>
                  <div className="preview-tags">
                    {suggestedTags.map(tag => (
                      <span key={tag} className="preview-tag">#{tag}</span>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}
        </div>
      ) : (
        <div className="quick-todo-section">
          <div className="quick-todo-container">
            <input 
              type="text" 
              className="quick-todo-input" 
              placeholder="Êñ∞„Åó„ÅÑTodo„ÅÆ„Çø„Ç§„Éà„É´..."
              value={newTodoTitle}
              onChange={(e) => setNewTodoTitle(e.target.value)}
              onKeyPress={handleKeyPress}
            />
            <select 
              className="priority-select"
              value={newTodoPriority}
              onChange={(e) => setNewTodoPriority(e.target.value)}
            >
              <option value="low">‰Ωé</option>
              <option value="medium">‰∏≠</option>
              <option value="high">È´ò</option>
            </select>
            <button 
              className="btn btn-primary" 
              onClick={addTodo}
              disabled={!newTodoTitle.trim()}
            >
              ËøΩÂä†
            </button>
          </div>
          
          {/* TodoË©≥Á¥∞ÂÖ•Âäõ */}
          <div className="todo-details">
            <textarea 
              className="todo-description-input"
              placeholder="Ë©≥Á¥∞Ë™¨ÊòéÔºà‰ªªÊÑèÔºâ"
              value={newTodoDescription}
              onChange={(e) => setNewTodoDescription(e.target.value)}
              rows="2"
            />
            <input 
              type="date" 
              className="todo-due-date-input"
              placeholder="ÊúüÈôêÊó•"
              value={newTodoDueDate}
              onChange={(e) => setNewTodoDueDate(e.target.value)}
            />
          </div>
        </div>
      )}
      
      <div className="memo-controls">
        <button className="btn btn-info" onClick={exportMemos}>
          „Ç®„ÇØ„Çπ„Éù„Éº„Éà
        </button>
        {activeTab === 'memos' && (
          <button className="btn btn-secondary" onClick={reindexMemos}>
            AIÊ§úÁ¥¢„ÇíÊõ¥Êñ∞
          </button>
        )}
        <button 
          className="btn btn-danger" 
          onClick={activeTab === 'memos' ? clearAllMemos : clearAllTodos}
        >
          ÂÖ®„Å¶ÂâäÈô§
        </button>
      </div>
      
      <div className="memo-list">
        {activeTab === 'memos' ? (
          filteredMemos.length === 0 ? (
            <div className="empty-state">
              <p>{getEmptyMessage()}</p>
            </div>
          ) : (
            filteredMemos.map(memo => (
              <MemoItem
                key={memo.id}
                memo={memo}
                onDelete={deleteMemo}
                onToggleFavorite={toggleFavorite}
                onUpdateCategory={updateMemoCategory}
                showSimilarity={isVectorSearch}
              />
            ))
          )
        ) : (
          todos.length === 0 ? (
            <div className="empty-state">
              <p>Todo„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÊñ∞„Åó„ÅÑTodo„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
            </div>
          ) : (
            <div className="kanban-board">
              <KanbanColumn
                title="üìã Êú™ÁùÄÊâã"
                status="todo"
                todos={todos.filter(t => t.status === 'todo')}
                onDrop={handleDrop}
                onDragOver={handleDragOver}
                onDelete={deleteTodo}
                onDragStart={handleDragStart}
              />
              <KanbanColumn
                title="üöß ÈÄ≤Ë°å‰∏≠"
                status="inprogress"
                todos={todos.filter(t => t.status === 'inprogress')}
                onDrop={handleDrop}
                onDragOver={handleDragOver}
                onDelete={deleteTodo}
                onDragStart={handleDragStart}
              />
              <KanbanColumn
                title="‚úÖ ÂÆå‰∫Ü"
                status="done"
                todos={todos.filter(t => t.status === 'done')}
                onDrop={handleDrop}
                onDragOver={handleDragOver}
                onDelete={deleteTodo}
                onDragStart={handleDragStart}
              />
            </div>
          )
        )}
      </div>
    </div>
  );
};

export default App;